// src/compiler/codegen.rs

use crate::ast::node::{
    Block, Expression, Item, Literal, Pattern, Program, Statement, Type, ImplItem, Span
};
use crate::error::{Error, FlunoResult};
use std::collections::HashMap;

pub type SourceMap = Vec<(usize, Span)>;

pub struct CodeGenerator {
    code: String,
    indent_level: usize,
    type_env: HashMap<String, Type>,
    source_map: SourceMap,
}

impl CodeGenerator {
    pub fn new() -> Self {
        Self {
            code: String::new(),
            indent_level: 0,
            type_env: HashMap::new(),
            source_map: Vec::new(),
        }
    }

    fn mark_span(&mut self, span: Span) {
        let line_cnt = self.code.lines().count();
        let line_number = if self.code.ends_with('\n') {
            line_cnt + 1
        } else {
            if line_cnt == 0 { 1 } else { line_cnt }
        };
        self.source_map.push((line_number, span));
    }

    fn is_copy_type(ty: &Type) -> bool {
        matches!(ty, 
            Type::Int | Type::Float | Type::Bool | Type::Unit |
            Type::Gaussian | Type::Uniform | Type::Beta | Type::Bernoulli
        )
    }

    fn infer_type_from_expr(expr: Option<&Expression>) -> Type {
        match expr {
            Some(Expression::Literal { value, .. }) => match value {
                Literal::Int(_) => Type::Int,
                Literal::Float(_) => Type::Float,
                Literal::Bool(_) => Type::Bool,
                Literal::String(_) => Type::String,
                Literal::Unit => Type::Unit,
            },
            Some(Expression::Call { callee, .. }) => {
                if let Expression::Variable { name, .. } = callee.as_ref() {
                    let func_name = name.to_string();
                    match func_name.as_str() {
                        "Gaussian" => Type::Gaussian,
                        "Uniform" => Type::Uniform,
                        "Beta" => Type::Beta,
                        "Bernoulli" => Type::Bernoulli,
                        _ => Type::Any,
                    }
                } else {
                    Type::Any
                }
            }
            Some(Expression::Array { .. }) => Type::Array(Box::new(Type::Any)),
            Some(Expression::Struct { name, .. }) => Type::Named {
                name: crate::ast::node::Path::from_ident(name.clone()),
                type_args: vec![],
            },
            _ => Type::Any,
        }
    }

    pub fn generate(&mut self, program: &Program) -> FlunoResult<(String, SourceMap)> {
        self.push_line("// Generated by Fluno Compiler");
        
        self.push_line("#![allow(unused_variables)]");
        self.push_line("#![allow(dead_code)]");
        self.push_line("#![allow(unused_parens)]");
        self.push_line("#![allow(non_snake_case)]"); 
        self.push_line("#![allow(unused_imports)]");
        self.push_line("");

        self.push_line("use fluno::prelude::*;");
        self.push_line("");

        for item in &program.items {
            self.gen_item(item)?;
        }

        Ok((self.code.clone(), self.source_map.clone()))
    }


    fn gen_item(&mut self, item: &Item) -> FlunoResult<()> {
        match item {
            Item::Function(func) => {
                let is_main = func.name.name == "main";
                if is_main {
                    self.push_line("#[tokio::main]");
                }

                if func.is_async || is_main {
                    self.push("async ");
                }
                self.push("fn ");
                self.push(&func.name.name);
                self.push("(");
                
                let saved_type_env = self.type_env.clone();
                
                for (i, param) in func.params.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.push(&param.name.name);
                    self.push(": ");
                    self.gen_type(&param.ty)?;
                    
                    self.type_env.insert(param.name.name.clone(), param.ty.clone());
                }
                self.push(") ");

                if let Some(ret_ty) = &func.return_type {
                    if *ret_ty != Type::Unit {
                        self.push("-> ");
                        self.gen_type(ret_ty)?;
                        self.push(" ");
                    }
                }

                self.gen_block(&func.body)?;
                self.push_line("");
                
                self.type_env = saved_type_env;
            }
            Item::Struct(struct_def) => {
                self.push_line("#[derive(Debug, Clone)]"); 
                self.push("pub struct ");
                self.push(&struct_def.name.name);
                self.push(" {\n");
                
                self.indent_level += 1;
                for field in &struct_def.fields {
                    self.indent();
                    self.push("pub ");
                    self.push(&field.name.name);
                    self.push(": ");
                    self.gen_type(&field.ty)?; 
                    self.push(",\n");
                }
                self.indent_level -= 1;
                
                self.indent();
                self.push("}\n\n");
                
            }
            Item::Impl(impl_block) => {
                self.push("impl ");
                let is_trait_impl = impl_block.trait_ref.is_some();

                if let Some(trait_ref) = &impl_block.trait_ref {
                    self.gen_type(trait_ref)?;
                    self.push(" for ");
                }

                self.gen_type(&impl_block.self_ty)?;
                self.push(" {\n");
                
                self.indent_level += 1;
                for item in &impl_block.items {
                    match item {
                        ImplItem::Method(func_def) => {
                            self.indent();
                            if !is_trait_impl {
                                self.push("pub "); 
                            }
                            self.push("fn ");
                            self.push(&func_def.name.name);
                            self.push("(");
                            
                            for (i, param) in func_def.params.iter().enumerate() {
                                if i > 0 { self.push(", "); }
                                if param.name.name == "self" {
                                    self.push("&self");
                                } else {
                                    self.push(&param.name.name);
                                    self.push(": ");
                                    self.gen_type(&param.ty)?;
                                }
                            }
                            self.push(") -> ");
                            if let Some(ret) = &func_def.return_type {
                                self.gen_type(ret)?;
                            } else {
                                self.push("()");
                            }
                            self.push(" ");
                            
                            self.gen_block(&func_def.body)?;
                            self.push("\n\n");
                        }
                        ImplItem::AssocType(_) => {
                            self.push_line("// TODO: Associated Type");
                        }
                    }
                }
                self.indent_level -= 1;
                
                self.indent();
                self.push("}\n\n");
            }
            Item::Enum(enum_def) => {
                self.push_line("#[derive(Debug, Clone)]"); 
                self.push("pub enum ");
                self.push(&enum_def.name.name);
                self.push(" {\n");
                
                self.indent_level += 1;
                for variant in &enum_def.variants {
                    self.indent();
                    self.push(&variant.name.name);
                    
                    match &variant.data {
                        crate::ast::node::VariantData::Unit => {},
                        crate::ast::node::VariantData::Tuple(types) => {
                            self.push("(");
                            for (i, ty) in types.iter().enumerate() {
                                if i > 0 { self.push(", "); }
                                self.gen_type(ty)?;
                            }
                            self.push(")");
                        },
                        crate::ast::node::VariantData::Struct(fields) => {
                            self.push(" {");
                            self.indent_level += 1;
                            self.push("\n");
                            for field in fields {
                                self.indent();
                                self.push(&field.name.name);
                                self.push(": ");
                                self.gen_type(&field.ty)?;
                                self.push(",\n");
                            }
                            self.indent_level -= 1;
                            self.indent();
                            self.push("}");
                        }
                    }
                    self.push(",\n");
                }
                self.indent_level -= 1;
                
                self.indent();
                self.push("}\n\n");
            }
            Item::Trait(trait_def) => {
                self.push("pub trait ");
                self.push(&trait_def.name.name);
                self.push(" {\n");
                self.indent_level += 1;

                for method in &trait_def.methods {
                    self.indent();
                    self.push("fn ");
                    self.push(&method.name.name);
                    self.push("(");

                    for (i, param) in method.params.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        if param.name.name == "self" {
                            self.push("&self");
                        } else {
                            self.push(&param.name.name);
                            self.push(": ");
                            self.gen_type(&param.ty)?;
                        }
                    }
                    self.push(")");

                    if let Some(ret) = &method.return_type {
                        if *ret != Type::Unit {
                            self.push(" -> ");
                            self.gen_type(ret)?;
                        }
                    }
                    self.push(";\n"); 
                }

                self.indent_level -= 1;
                self.indent();
                self.push("}\n\n");
            }
            Item::TypeAlias(alias) => {
                self.push("pub type ");
                self.push(&alias.name.name);
                self.push(" = ");
                self.gen_type(&alias.ty)?;
                self.push(";\n\n");
            }
            Item::Module(m) => {
                self.push("mod ");
                self.push(&m.name.name);
                self.push(" {\n");
                self.indent_level += 1;
                for item in &m.items {
                    self.gen_item(item)?;
                }
                self.indent_level -= 1;
                self.push_line("}");
            }
            Item::Import(_) => {
                self.push_line("// Import omitted in codegen");
            }
            Item::Extern(ext) => {
                for attr in &ext.attributes {
                    if let crate::ast::node::Attribute::Nested(id, inner) = attr {
                        if id.name == "link" {
                            self.indent();
                            self.push("#[link(");
                            for (i, inner_attr) in inner.iter().enumerate() {
                                if i > 0 { self.push(", "); }
                                if let crate::ast::node::Attribute::Value(key, crate::ast::node::Literal::String(val)) = inner_attr {
                                    self.push(&key.name);
                                    self.push(" = \"");
                                    self.push(val);
                                    self.push("\"");
                                }
                            }
                            self.push_line(")]");
                        }
                    }
                }
                
                self.indent();
                self.push("extern \"");
                self.push(&ext.abi);
                self.push_line("\" {");
                self.indent_level += 1;
                for f in &ext.functions {
                    if f.is_async {
                        self.indent();
                        self.push_line("// NOTE: Async extern fn is not directly supported in Rust FFI.");
                        self.indent();
                        self.push("// Original: async fn ");
                        self.push(&f.name.name);
                        self.push_line("(...)");
                        continue;
                    }
                    
                    self.indent();
                    self.push("fn ");
                    self.push(&f.name.name);
                    self.push("(");
                    for (i, param) in f.params.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        self.push(&param.name.name);
                        self.push(": ");
                        self.gen_type(&param.ty)?;
                    }
                    self.push(")");
                    if let Some(ret) = &f.return_type {
                        if *ret != Type::Unit {
                            self.push(" -> ");
                            self.gen_type(ret)?;
                        }
                    }
                    self.push_line(";");
                }
                self.indent_level -= 1;
                self.indent();
                self.push_line("}");
            }
        }

        Ok(())
    }

    fn gen_type(&mut self, ty: &Type) -> FlunoResult<()> {
        match ty {
            Type::Int => self.push("i64"),
            Type::Float => self.push("ADFloat"),
            Type::Bool => self.push("bool"),
            Type::String => self.push("String"),
            Type::Unit => self.push("()"),
            Type::Gaussian => self.push("Gaussian"),
            Type::Uniform => self.push("Uniform"),
            Type::Beta => self.push("Beta"),
            Type::Bernoulli => self.push("Bernoulli"),
            
            Type::Named { name, .. } => self.push(&name.to_string()),

            Type::Signal(inner) => {
                self.push("Signal<");
                self.gen_type(inner)?;
                self.push(">");
            },
            Type::Array(inner) => {
                self.push("Vec<");
                self.gen_type(inner)?;
                self.push(">");
            },
            Type::Option(inner) => {
                self.push("Option<");
                self.gen_type(inner)?;
                self.push(">");
            },
            Type::Map(key, val) => {
                self.push("std::collections::HashMap<");
                self.gen_type(key)?;
                self.push(", ");
                self.gen_type(val)?;
                self.push(">");
            },
            Type::Any => self.push("fluno::vm::Value"),
            
            Type::Result { ok_type, err_type } => {
                self.push("Result<");
                self.gen_type(ok_type)?;
                self.push(", ");
                self.gen_type(err_type)?;
                self.push(">");
            },

            Type::Function { params, return_type } => {
                self.push("impl Fn(");
                for (i, param_ty) in params.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_type(param_ty)?;
                }
                self.push(") -> ");
                self.gen_type(return_type)?;
                self.push(" + 'static"); 
            },

            _ => return Err(Error::CompilationError(format!("Type {} not supported yet", ty))),
        }
        Ok(())
    }


    fn gen_block(&mut self, block: &Block) -> FlunoResult<()> {
        self.push_line("{");
        self.indent_level += 1;
        
        let len = block.statements.len();
        for (i, stmt) in block.statements.iter().enumerate() {
            let is_last = i == len - 1;
            self.gen_statement(stmt, is_last)?;
        }
        
        self.indent_level -= 1;
        self.indent();
        self.push("}\n");
        Ok(())
    }


    fn gen_statement(&mut self, stmt: &Statement, _is_last: bool) -> FlunoResult<()> {
        match stmt {
            Statement::Let { pattern, init, ty, span, .. } => {
                self.mark_span(*span);
                self.indent();
                self.push("let mut "); 
                self.gen_pattern(pattern)?; 
                
                if let Pattern::Identifier { name, .. } = pattern {
                    let var_type = ty.clone().unwrap_or_else(|| {
                        Self::infer_type_from_expr(init.as_ref())
                    });
                    self.type_env.insert(name.name.clone(), var_type);
                }
                
                if let Some(t) = ty {
                    self.push(": ");
                    self.gen_type(t)?;
                }

                if let Some(expr) = init {
                    self.push(" = ");
                    self.gen_expression(expr)?;
                }
                self.push(";\n");
            }
            Statement::Expression(expr) => {
                self.mark_span(expr.span()); 
                self.indent();
                self.gen_expression(expr)?;
                if !_is_last {
                    self.push(";");
                }
                self.push("\n");
            }

            Statement::Return { value, span } => {
                self.mark_span(*span);
                self.indent();
                self.push("return ");
                if let Some(v) = value {
                    self.gen_expression(v)?;
                }
                self.push(";\n");
            }
            Statement::While { condition, body, span } => {
                self.mark_span(*span);
                self.indent();
                self.push("while ");
                self.gen_expression(condition)?;
                self.push(" ");
                self.gen_block(body)?;
            }
            Statement::For { pattern, iterator, body, span } => {
                self.mark_span(*span);
                self.indent();
                self.push("for ");
                self.gen_pattern(pattern)?;
                
                if let Pattern::Identifier { name, .. } = pattern {
                    self.type_env.insert(name.name.clone(), Type::Any);
                }
                
                self.push(" in ");
                self.gen_expression(iterator)?;
                self.push(" ");
                self.gen_block(body)?;
            }
            _ => return Err(Error::CompilationError("Statement not supported yet".to_string())),
        }
        Ok(())
    }

    fn gen_expression(&mut self, expr: &Expression) -> FlunoResult<()> {
        self.mark_span(expr.span());

        match expr {
            Expression::FieldAccess { object, field, .. } => {
                self.gen_expression(object)?;
                self.push(".");
                self.push(&field.name);
            }
            Expression::Literal { value, .. } => self.gen_literal(value)?,
            Expression::Variable { name, .. } => {
                let var_name = name.to_string();
                self.push(&var_name);
                
                if let Some(ty) = self.type_env.get(&var_name) {
                    if !Self::is_copy_type(ty) {
                        self.push(".clone()");
                    }
                }
            }
            Expression::Binary { left, op, right, .. } => {
                self.push("(");
                self.gen_expression(left)?;
                self.push(&format!(" {} ", op)); 
                self.gen_expression(right)?;
                self.push(")");
            }
            Expression::Call { callee, args, .. } => {
                self.gen_expression(callee)?;
                self.push("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_expression(arg)?;
                }
                self.push(")");
            }
            Expression::Block { block, .. } => self.gen_block(block)?,
            Expression::If { condition, then_branch, else_branch, .. } => {
                self.push("if ");
                self.gen_expression(condition)?;
                self.push(" ");
                self.gen_block(then_branch)?;
                if let Some(else_b) = else_branch {
                    self.push(" else ");
                    self.gen_block(else_b)?;
                }
            }
            Expression::Match { scrutinee, arms, .. } => {
                self.push("match ");
                self.gen_expression(scrutinee)?;
                self.push(" {");
                self.indent_level += 1;
                self.push("\n");
                
                for arm in arms {
                    self.indent();
                    self.gen_pattern(&arm.pattern)?;
                    self.push(" => ");
                    self.gen_expression(&arm.body)?;
                    self.push(",\n");
                }

                self.indent_level -= 1;
                self.indent();
                self.push("}");
            }
            Expression::Array { elements, .. } => {
                self.push("vec![");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_expression(elem)?;
                }
                self.push("]");
            }
            Expression::Some { expr, .. } => {
                self.push("Some(");
                self.gen_expression(expr)?;
                self.push(")");
            }
            Expression::None { .. } => self.push("None"),
            Expression::Ok { expr, .. } => {
                self.push("Ok(");
                self.gen_expression(expr)?;
                self.push(")");
            }
            Expression::Err { expr, .. } => {
                self.push("Err(");
                self.gen_expression(expr)?;
                self.push(")");
            }
            Expression::Lambda { params, body, .. } => {
                self.push("move |");
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        self.push(", ");
                    }
                    self.push(&param.name.name);
                }
                self.push("| ");

                match body.as_ref() {
                    Expression::Block { block, .. } => {
                        self.push("{\n");
                        self.indent_level += 1;
                        
                        for stmt in &block.statements {
                             self.indent();
                             self.gen_statement(stmt, false)?;
                        }

                        self.indent_level -= 1;
                        self.indent();
                        self.push("}");
                    }
                    _ => {
                        self.push("{ ");
                        self.gen_expression(body)?;
                        self.push(" }");
                    }
                }
            }
            Expression::Index { object, index, .. } => {
                self.gen_expression(object)?;
                self.push("[");
                
                self.push("(");
                self.gen_expression(index)?;
                self.push(") as usize");
                
                self.push("]");
            }
            Expression::Struct { name, fields, .. } => {
                self.push(&name.name);
                self.push(" { ");
                for (i, field) in fields.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.push(&field.name.name);
                    self.push(": ");
                    self.gen_expression(&field.value)?;
                }
                self.push(" }");
            }
            Expression::MethodCall { receiver, method, args, .. } => {
                self.gen_expression(receiver)?;
                self.push(".");
                self.push(&method.name);
                self.push("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_expression(arg)?;
                }
                self.push(")");
            }

            Expression::Await { expr, .. } => {
                self.gen_expression(expr)?;
                self.push(".await");
            }

            Expression::Enum { name, variant, args, .. } => {
                self.push(&name.name);
                self.push("::");
                self.push(&variant.name);
                if !args.is_empty() {
                    self.push("(");
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        self.gen_expression(arg)?;
                    }
                    self.push(")");
                }
            }
            Expression::UfcsMethod { trait_path, method, .. } => {
                self.push(&trait_path.to_string());
                self.push("::");
                self.push(&method.name);
            }
             _ => return Err(Error::CompilationError(format!("Expression {:?} not supported yet", expr))),
        }

        Ok(())
    }

    fn gen_pattern(&mut self, pattern: &Pattern) -> FlunoResult<()> {
        match pattern {
            Pattern::Identifier { name, .. } => self.push(&name.name),
            
            Pattern::Wildcard { .. } => self.push("_"),
            
            Pattern::Literal { value, .. } => self.gen_literal(value)?,

            Pattern::Some { pattern, .. } => {
                self.push("Some(");
                self.gen_pattern(pattern)?;
                self.push(")");
            },

            Pattern::None { .. } => self.push("None"),

            Pattern::Ok { pattern, .. } => {
                self.push("Ok(");
                self.gen_pattern(pattern)?;
                self.push(")");
            },

            Pattern::Err { pattern, .. } => {
                self.push("Err(");
                self.gen_pattern(pattern)?;
                self.push(")");
            },

            Pattern::Tuple { patterns, .. } => {
                self.push("(");
                for (i, p) in patterns.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_pattern(p)?;
                }
                self.push(")");
            },

            Pattern::Enum { name, variant, args, named_fields, .. } => {
                self.push(&name.name);
                self.push("::");
                self.push(&variant.name);
                
                if let Some(fields) = named_fields {
                    self.push(" { ");
                    for (i, field) in fields.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        self.push(&field.name.name);
                        if let Some(pat) = &field.pattern {
                            self.push(": ");
                            self.gen_pattern(pat)?;
                        }
                    }
                    self.push(" }");
                } else if !args.is_empty() {
                    self.push("(");
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        self.gen_pattern(arg)?;
                    }
                    self.push(")");
                }
            },

            Pattern::Struct { name, fields, .. } => {
                self.push(&name.name);
                self.push(" { ");
                for (i, field) in fields.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.push(&field.name.name);
                    if let Some(pat) = &field.pattern {
                        self.push(": ");
                        self.gen_pattern(pat)?;
                    }
                }
                self.push(" }");
            },

            _ => return Err(Error::CompilationError(format!("Pattern {:?} not supported yet", pattern))),
        }
        Ok(())
    }

    fn gen_literal(&mut self, lit: &Literal) -> FlunoResult<()> {
        match lit {
            Literal::Int(i) => self.push(&i.to_string()),
            Literal::Float(f) => {
                let mut s = f.to_string();
                if !s.contains('.') { s.push_str(".0"); }
                self.push(&format!("ADFloat::from({})", s));
            }
            Literal::Bool(b) => self.push(&b.to_string()),
            Literal::String(s) => self.push(&format!("\"{}\".to_string()", s)),
            Literal::Unit => self.push("()"),
        }
        Ok(())
    }

    fn push(&mut self, s: &str) {
        self.code.push_str(s);
    }

    fn push_line(&mut self, s: &str) {
        self.indent();
        self.code.push_str(s);
        self.code.push('\n');
    }

    fn indent(&mut self) {
        self.code.push_str(&"    ".repeat(self.indent_level));
    }
}
