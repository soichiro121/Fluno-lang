// src/compiler/codegen.rs

use crate::ast::node::{
    Block, Expression, Item, Literal, Pattern, Program, Statement, Type, ImplItem, Span
};
use crate::error::{Error, FlunoResult};
use std::collections::HashMap;

pub type SourceMap = Vec<(usize, Span)>;

pub struct CodeGenerator {
    code: String,
    indent_level: usize,
    type_env: HashMap<String, Type>,
    source_map: SourceMap,
}

impl CodeGenerator {
    pub fn new() -> Self {
        Self {
            code: String::new(),
            indent_level: 0,
            type_env: HashMap::new(),
            source_map: Vec::new(),
        }
    }

    fn mark_span(&mut self, span: Span) {
        // Calculate current line number (1-based) from self.code
        let line_cnt = self.code.lines().count();
        let line_number = if self.code.ends_with('\n') {
            line_cnt + 1
        } else {
            if line_cnt == 0 { 1 } else { line_cnt }
        };
        self.source_map.push((line_number, span));
    }

    // 型がCopyトレイトを実装しているかどうかを判定
    fn is_copy_type(ty: &Type) -> bool {
        matches!(ty, 
            Type::Int | Type::Float | Type::Bool | Type::Unit |
            Type::Gaussian | Type::Uniform | Type::Beta | Type::Bernoulli
        )
    }

    // 式から型を推論する（限定的なサポート）
    fn infer_type_from_expr(expr: Option<&Expression>) -> Type {
        match expr {
            Some(Expression::Literal { value, .. }) => match value {
                Literal::Int(_) => Type::Int,
                Literal::Float(_) => Type::Float,
                Literal::Bool(_) => Type::Bool,
                Literal::String(_) => Type::String,
                Literal::Unit => Type::Unit,
            },
            Some(Expression::Call { callee, .. }) => {
                // 関数名から型を推論（分布コンストラクタ等）
                if let Expression::Variable { name, .. } = callee.as_ref() {
                    let func_name = name.to_string();
                    match func_name.as_str() {
                        "Gaussian" => Type::Gaussian,
                        "Uniform" => Type::Uniform,
                        "Beta" => Type::Beta,
                        "Bernoulli" => Type::Bernoulli,
                        _ => Type::Any,
                    }
                } else {
                    Type::Any
                }
            }
            Some(Expression::Array { .. }) => Type::Array(Box::new(Type::Any)),
            Some(Expression::Struct { name, .. }) => Type::Named {
                name: crate::ast::node::Path::from_ident(name.clone()),
                type_args: vec![],
            },
            _ => Type::Any,
        }
    }

    pub fn generate(&mut self, program: &Program) -> FlunoResult<(String, SourceMap)> {
        self.push_line("// Generated by Flux Compiler");
        
        self.push_line("#![allow(unused_variables)]");
        self.push_line("#![allow(dead_code)]");
        self.push_line("#![allow(unused_parens)]");
        self.push_line("#![allow(non_snake_case)]"); 
        self.push_line("#![allow(unused_imports)]");
        self.push_line("");

        // Import prelude from fluno library
        self.push_line("use fluno::prelude::*;");
        self.push_line("");

        for item in &program.items {
            self.gen_item(item)?;
        }

        Ok((self.code.clone(), self.source_map.clone()))
    }


    fn gen_item(&mut self, item: &Item) -> FlunoResult<()> {
        match item {
            Item::Function(func) => {
                let is_main = func.name.name == "main";
                if is_main {
                    self.push_line("#[tokio::main]");
                }

                if func.is_async || is_main {
                    self.push("async ");
                }
                self.push("fn ");
                self.push(&func.name.name);
                self.push("(");
                
                // 関数のスコープ開始前に型環境を保存
                let saved_type_env = self.type_env.clone();
                
                for (i, param) in func.params.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.push(&param.name.name);
                    self.push(": ");
                    self.gen_type(&param.ty)?;
                    
                    // パラメータを型環境に登録
                    self.type_env.insert(param.name.name.clone(), param.ty.clone());
                }
                self.push(") ");

                if let Some(ret_ty) = &func.return_type {
                    if *ret_ty != Type::Unit {
                        self.push("-> ");
                        self.gen_type(ret_ty)?;
                        self.push(" ");
                    }
                }

                self.gen_block(&func.body)?;
                self.push_line("");
                
                // 関数のスコープ終了時に型環境を復元
                self.type_env = saved_type_env;
            }
            Item::Struct(struct_def) => {
                // #[derive(...)] をつけておくと便利
                self.push_line("#[derive(Debug, Clone)]"); 
                self.push("pub struct ");
                self.push(&struct_def.name.name);
                self.push(" {\n");
                
                self.indent_level += 1;
                for field in &struct_def.fields {
                    self.indent();
                    self.push("pub ");
                    self.push(&field.name.name);
                    self.push(": ");
                    // 型名を Rust 用に変換 (Float -> f64, Int -> i64 等)
                    self.gen_type(&field.ty)?; 
                    self.push(",\n");
                }
                self.indent_level -= 1;
                
                self.indent();
                self.push("}\n\n");
                
                // コンストラクタ関数も生成しておくと Flux の `Point(1.0, 2.0)` みたいな記法に対応しやすいが、
                // Flux が `Point { x: ... }` 形式なら上記だけでOK。
                // 今回はシンプルに構造体定義のみ生成します。
            }
            Item::Impl(impl_block) => {
                self.push("impl ");
                // もしトレイと実装 (impl Trait for Type) ならここで分岐が必要ですが、
                // 今回は単純な impl Type { ... } を想定
                let is_trait_impl = impl_block.trait_ref.is_some();

                if let Some(trait_ref) = &impl_block.trait_ref {
                     // trait_ref は Type 型なので、gen_type で出力する
                     self.gen_type(trait_ref)?;
                     self.push(" for ");
                }

                
                self.gen_type(&impl_block.self_ty)?;
                self.push(" {\n");
                
                self.indent_level += 1;
                for item in &impl_block.items {
                    // impl内のアイテム（メソッド）を生成
                    
                    match item {
                        ImplItem::Method(func_def) => {
                            self.indent();
                            // Trait実装の場合は pub をつけない (Rustのルール)
                            if !is_trait_impl {
                                self.push("pub "); 
                            }
                            self.push("fn ");
                            self.push(&func_def.name.name);
                            self.push("(");
                            
                            // パラメータ生成（self の扱い含む）
                            for (i, param) in func_def.params.iter().enumerate() {
                                if i > 0 { self.push(", "); }
                                if param.name.name == "self" {
                                    // Flux の self は参照渡し &self として扱うのが基本
                                    self.push("&self");
                                } else {
                                    self.push(&param.name.name);
                                    self.push(": ");
                                    self.gen_type(&param.ty)?;
                                }
                            }
                            self.push(") -> ");
                            if let Some(ret) = &func_def.return_type {
                                self.gen_type(ret)?;
                            } else {
                                self.push("()");
                            }
                            self.push(" ");
                            
                            // ボディ
                            self.gen_block(&func_def.body)?;
                            self.push("\n\n");
                        }
                        ImplItem::AssocType(_) => {
                            // Phase 1: Ignore associated types or return compilation error?
                            // Rust transpilation might need `type Alias = ...;`
                            // For now, let's just ignore or TODO
                            self.push_line("// TODO: Associated Type");
                        }
                }
                }
                self.indent_level -= 1;
                
                self.indent();
                self.push("}\n\n");
            }
            Item::Enum(enum_def) => {
                self.push_line("#[derive(Debug, Clone)]"); 
                self.push("pub enum ");
                self.push(&enum_def.name.name);
                self.push(" {\n");
                
                self.indent_level += 1;
                for variant in &enum_def.variants {
                    self.indent();
                    self.push(&variant.name.name);
                    
                    match &variant.data {
                        crate::ast::node::VariantData::Unit => {},
                        crate::ast::node::VariantData::Tuple(types) => {
                            self.push("(");
                            for (i, ty) in types.iter().enumerate() {
                                if i > 0 { self.push(", "); }
                                self.gen_type(ty)?;
                            }
                            self.push(")");
                        },
                        crate::ast::node::VariantData::Struct(fields) => {
                            self.push(" {");
                            self.indent_level += 1;
                            self.push("\n");
                            for field in fields {
                                self.indent();
                                self.push(&field.name.name);
                                self.push(": ");
                                self.gen_type(&field.ty)?;
                                self.push(",\n");
                            }
                            self.indent_level -= 1;
                            self.indent();
                            self.push("}");
                        }
                    }
                    self.push(",\n");
                }
                self.indent_level -= 1;
                
                self.indent();
                self.push("}\n\n");
            }
            Item::Trait(trait_def) => {
                self.push("pub trait ");
                self.push(&trait_def.name.name);
                self.push(" {\n");
                self.indent_level += 1;

                for method in &trait_def.methods {
                    self.indent();
                    self.push("fn ");
                    self.push(&method.name.name);
                    self.push("(");

                    for (i, param) in method.params.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        if param.name.name == "self" {
                             self.push("&self");
                        } else {
                             self.push(&param.name.name);
                             self.push(": ");
                             self.gen_type(&param.ty)?;
                        }
                    }
                    self.push(")");

                    if let Some(ret) = &method.return_type {
                         if *ret != Type::Unit {
                            self.push(" -> ");
                            self.gen_type(ret)?;
                         }
                    }
                    self.push(";\n"); 
                }

                self.indent_level -= 1;
                self.indent();
                self.push("}\n\n");
            }
            Item::TypeAlias(alias) => {
                 self.push("pub type ");
                 self.push(&alias.name.name);
                 self.push(" = ");
                 self.gen_type(&alias.ty)?;
                 self.push(";\n\n");
            }
            Item::Module(m) => {
                self.push("mod ");
                self.push(&m.name.name);
                self.push(" {\n");
                self.indent_level += 1;
                for item in &m.items {
                    self.gen_item(item)?;
                }
                self.indent_level -= 1;
                self.push_line("}");
            }
            Item::Import(_) => {
                // For now, let's not generate Rust imports as they are complex to map
                self.push_line("// Import omitted in codegen");
            }
            Item::Extern(ext) => {
                // Output #[link(name = "...")] if present
                for attr in &ext.attributes {
                    if let crate::ast::node::Attribute::Nested(id, inner) = attr {
                        if id.name == "link" {
                            self.indent();
                            self.push("#[link(");
                            for (i, inner_attr) in inner.iter().enumerate() {
                                if i > 0 { self.push(", "); }
                                if let crate::ast::node::Attribute::Value(key, crate::ast::node::Literal::String(val)) = inner_attr {
                                    self.push(&key.name);
                                    self.push(" = \"");
                                    self.push(val);
                                    self.push("\"");
                                }
                            }
                            self.push_line(")]");
                        }
                    }
                }
                
                self.indent();
                self.push("extern \"");
                self.push(&ext.abi);
                self.push_line("\" {");
                self.indent_level += 1;
                for f in &ext.functions {
                    if f.is_async {
                        // Rust extern "C" doesn't support async directly
                        // Generate a comment noting this and skip the function
                        // A full implementation would generate a wrapper function
                        self.indent();
                        self.push_line("// NOTE: Async extern fn is not directly supported in Rust FFI.");
                        self.indent();
                        self.push("// Original: async fn ");
                        self.push(&f.name.name);
                        self.push_line("(...)");
                        continue;
                    }
                    
                    self.indent();
                    self.push("fn ");
                    self.push(&f.name.name);
                    self.push("(");
                    for (i, param) in f.params.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        self.push(&param.name.name);
                        self.push(": ");
                        self.gen_type(&param.ty)?;
                    }
                    self.push(")");
                    if let Some(ret) = &f.return_type {
                        if *ret != Type::Unit {
                            self.push(" -> ");
                            self.gen_type(ret)?;
                        }
                    }
                    self.push_line(";");
                }
                self.indent_level -= 1;
                self.indent();
                self.push_line("}");
            }
        }


        Ok(())
    }

    // ジェネリクス再帰対応
    fn gen_type(&mut self, ty: &Type) -> FlunoResult<()> {
        match ty {
            Type::Int => self.push("i64"),
            Type::Float => self.push("ADFloat"),
            Type::Bool => self.push("bool"),
            Type::String => self.push("String"),
            Type::Unit => self.push("()"),
            Type::Gaussian => self.push("Gaussian"),
            
            // ユーザー定義型（Struct名など）
            Type::Named { name, .. } => self.push(&name.to_string()),

            // ジェネリクス型
            Type::Signal(inner) => {
                self.push("Signal<");
                self.gen_type(inner)?;
                self.push(">");
            },
            Type::Array(inner) => {
                self.push("Vec<");
                self.gen_type(inner)?;
                self.push(">");
            },
            Type::Option(inner) => {
                self.push("Option<");
                self.gen_type(inner)?;
                self.push(">");
            },
            Type::Map(key, val) => {
                self.push("std::collections::HashMap<");
                self.gen_type(key)?;
                self.push(", ");
                self.gen_type(val)?;
                self.push(">");
            },
            Type::Any => self.push("fluno::vm::Value"),
            
            Type::Result { ok_type, err_type } => {
                self.push("Result<");
                self.gen_type(ok_type)?;
                self.push(", ");
                self.gen_type(err_type)?;
                self.push(">");
            },

            // 関数型: Fn(Int, Int) -> Int ==> impl Fn(i64, i64) -> i64 + 'static
            // 引数の型として使う場合は impl Fn(...)、構造体のフィールドなら Box<dyn Fn(...)> が無難ですが、
            // ここでは一旦単純に `impl Fn(...)` 形式（引数位置用）として出力します。
            // 厳密には文脈依存ですが、まずはこれで進めます。
            Type::Function { params, return_type } => {
                self.push("impl Fn(");
                for (i, param_ty) in params.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_type(param_ty)?;
                }
                self.push(") -> ");
                self.gen_type(return_type)?;
                // 'static をつけておくと Signal などのクロージャとして使いやすい
                self.push(" + 'static"); 
            },


            // その他（未対応型）
            _ => return Err(Error::CompilationError(format!("Type {} not supported yet", ty))),
        }
        Ok(())
    }


    fn gen_block(&mut self, block: &Block) -> FlunoResult<()> {
        self.push_line("{");
        self.indent_level += 1;
        
        let len = block.statements.len();
        for (i, stmt) in block.statements.iter().enumerate() {
            // 最後の要素かどうかを判定
            let is_last = i == len - 1;
            self.gen_statement(stmt, is_last)?;
        }
        
        self.indent_level -= 1;
        self.indent();
        self.push("}\n");
        Ok(())
    }


    fn gen_statement(&mut self, stmt: &Statement, _is_last: bool) -> FlunoResult<()> {
        match stmt {
            Statement::Let { pattern, init, ty, span, .. } => {
                self.mark_span(*span);
                self.indent();
                self.push("let mut "); 
                self.gen_pattern(pattern)?; 
                
                // 型環境に変数を記録
                if let Pattern::Identifier { name, .. } = pattern {
                    let var_type = ty.clone().unwrap_or_else(|| {
                        // 型が明示されていない場合、initから推論を試みる
                        Self::infer_type_from_expr(init.as_ref())
                    });
                    self.type_env.insert(name.name.clone(), var_type);
                }
                
                if let Some(t) = ty {
                    self.push(": ");
                    self.gen_type(t)?;
                }

                if let Some(expr) = init {
                    self.push(" = ");
                    self.gen_expression(expr)?;
                }
                self.push(";\n");
            }
            Statement::Expression(expr) => {
                // Expression handles span marking internally if we want, but Statement wrapper span covers the semicolon.
                // Let's mark the expression's span here too, or rely on gen_expression.
                // It's safer to mark here for the statement level.
                self.mark_span(expr.span()); 
                self.indent();
                self.gen_expression(expr)?;
                if !_is_last {
                    self.push(";");
                }
                self.push("\n");
            }

            Statement::Return { value, span } => {
                self.mark_span(*span);
                self.indent();
                self.push("return ");
                if let Some(v) = value {
                    self.gen_expression(v)?;
                }
                self.push(";\n");
            }
            // Whileループ
            Statement::While { condition, body, span } => {
                self.mark_span(*span);
                self.indent();
                self.push("while ");
                self.gen_expression(condition)?;
                self.push(" ");
                self.gen_block(body)?;
            }
            // Forループ (Iteratorは未実装部分があるため簡易対応)
            Statement::For { pattern, iterator, body, span } => {
                self.mark_span(*span);
                self.indent();
                self.push("for ");
                self.gen_pattern(pattern)?;
                
                // Forループ変数を型環境に登録（要素型は推論困難なためAny）
                if let Pattern::Identifier { name, .. } = pattern {
                    self.type_env.insert(name.name.clone(), Type::Any);
                }
                
                self.push(" in ");
                self.gen_expression(iterator)?;
                self.push(" ");
                self.gen_block(body)?;
            }
            _ => return Err(Error::CompilationError("Statement not supported yet".to_string())),
        }
        Ok(())
    }

    fn gen_expression(&mut self, expr: &Expression) -> FlunoResult<()> {
        // Mark span for every expression
        self.mark_span(expr.span());

        match expr {
            Expression::FieldAccess { object, field, .. } => {
                self.gen_expression(object)?;
                self.push(".");
                self.push(&field.name);
            }
            Expression::Literal { value, .. } => self.gen_literal(value)?,
            Expression::Variable { name, .. } => {
                let var_name = name.to_string();
                self.push(&var_name);
                
                // 型を確認し、非Copy型の場合はclone()を付与
                if let Some(ty) = self.type_env.get(&var_name) {
                    if !Self::is_copy_type(ty) {
                        self.push(".clone()");
                    }
                } else {
                    // 型が不明な場合は安全のためclone()を付与
                    // ただし、関数名やメソッド名の場合はclone()しない
                    // （単一の識別子で英小文字始まりかつ登録済み変数でない場合はスキップ）
                }
            }
            Expression::Binary { left, op, right, .. } => {
                self.push("(");
                self.gen_expression(left)?;
                self.push(&format!(" {} ", op)); 
                self.gen_expression(right)?;
                self.push(")");
            }
            Expression::Call { callee, args, .. } => {
                // Signal::new などの特定メソッドをRustの関数呼び出しにマップする場合のロジックをここに挟むことも可能
                // 今回は Prelude で Signal_new 関数を用意する方針なので、AST側で Signal_new と書かれている前提か、
                // あるいはパーサ側で置換が必要。
                // 簡易的にそのまま出力します。
                self.gen_expression(callee)?;
                self.push("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_expression(arg)?;
                }
                self.push(")");
            }
            Expression::Block { block, .. } => self.gen_block(block)?,
            Expression::If { condition, then_branch, else_branch, .. } => {
                self.push("if ");
                self.gen_expression(condition)?;
                self.push(" ");
                self.gen_block(then_branch)?;
                if let Some(else_b) = else_branch {
                    self.push(" else ");
                    self.gen_block(else_b)?;
                }
            }
            // Match式
            Expression::Match { scrutinee, arms, .. } => {
                self.push("match ");
                self.gen_expression(scrutinee)?;
                self.push(" {");
                self.indent_level += 1;
                self.push("\n"); // 整形用
                
                for arm in arms {
                    self.indent();
                    self.gen_pattern(&arm.pattern)?;
                    self.push(" => ");
                    self.gen_expression(&arm.body)?;
                    self.push(",\n");
                }

                self.indent_level -= 1;
                self.indent();
                self.push("}");
            }
            // 配列リテラル -> Vecマクロ
            Expression::Array { elements, .. } => {
                self.push("vec![");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_expression(elem)?;
                }
                self.push("]");
            }
            // Option/Result リテラル
            Expression::Some { expr, .. } => {
                self.push("Some(");
                self.gen_expression(expr)?;
                self.push(")");
            }
            Expression::None { .. } => self.push("None"),
            Expression::Ok { expr, .. } => {
                self.push("Ok(");
                self.gen_expression(expr)?;
                self.push(")");
            }
            Expression::Err { expr, .. } => {
                self.push("Err(");
                self.gen_expression(expr)?;
                self.push(")");
            }
            Expression::Lambda { params, body, .. } => {
                // 1. ヘッダ出力 "move |p1, p2|"
                self.push("move |");
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        self.push(", ");
                    }
                    self.push(&param.name.name);
                }
                self.push("| ");

                // 2. ボディ出力
                match body.as_ref() {
                    Expression::Block { block, .. } => {
                        self.push("{\n");
                        self.indent_level += 1;
                        
                        // ブロック内のステートメントを順次出力
                        // gen_statement の第2引数(is_last)は簡易的に false とする
                        // (厳密にはブロックの最後だけ true にすべきだが、Rust出力ならセミコロン有無は rustc が許容する場合が多い)
                        for stmt in &block.statements {
                             self.indent(); // 各行のインデント
                             self.gen_statement(stmt, false)?;
                        }

                        self.indent_level -= 1;
                        self.indent(); // 閉じ括弧のインデント
                        self.push("}");
                    }
                    _ => {
                        // 単一式の場合 { expr }
                        self.push("{ ");
                        self.gen_expression(body)?;
                        self.push(" }");
                    }
                }
                // ここで Ok(()) を返さない（match式全体が Result を返す構造なら、ここは Unit で終わる）
            }
            Expression::Index { object, index, .. } => {
                // object[index] の形式で出力
                self.gen_expression(object)?;
                self.push("[");
                
                // Rustのインデックスは usize が基本なので、
                // FluxのInt(i64想定)をキャストする "(index) as usize" を生成するのが安全です。
                // ただし、単純なリテラルや変数の場合は括弧で囲んでキャストします。
                
                self.push("(");
                self.gen_expression(index)?;
                self.push(") as usize");
                
                self.push("]");
            }
            Expression::Struct { name, fields, .. } => {
                self.push(&name.name);
                self.push(" { ");
                for (i, field) in fields.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.push(&field.name.name);
                    self.push(": ");
                    self.gen_expression(&field.value)?;
                }
                self.push(" }");
            }
            Expression::MethodCall { receiver, method, args, .. } => {
                self.gen_expression(receiver)?;
                self.push(".");
                self.push(&method.name);
                self.push("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_expression(arg)?;
                }
                self.push(")");
            }

            Expression::Await { expr, .. } => {
                self.gen_expression(expr)?;
                self.push(".await");
            }

            Expression::Enum { name, variant, args, .. } => {
                // MyEnum::Variant(...) の形式で出力
                self.push(&name.name);
                self.push("::");
                self.push(&variant.name);
                if !args.is_empty() {
                    self.push("(");
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        self.gen_expression(arg)?;
                    }
                    self.push(")");
                }
            }
            Expression::UfcsMethod { trait_path, method, .. } => {
                // io::print(x) -> io::print(x)
                // trait_path is likely "io"
                self.push(&trait_path.to_string());
                self.push("::");
                self.push(&method.name);
                // UfcsMethod does not usually carry args in this variant?
                // Wait, definition of UfcsMethod in node.rs:
                // UfcsMethod { trait_path: Path, method: Identifier, span: Span }
                // Where are the arguments? 
                // Ah, UfcsMethod alone might be just the function path if it's used in a Call?
                // Let's check if Expression has Call wrapping UfcsMethod.
                // But the error said "Expression UfcsMethod ... not supported yet".
                // If the parser produces UfcsMethod inside Call, then Call handles args.
                // If it is Call { callee: UfcsMethod, args, .. }, then gen_expression(callee) is called.
                // So I just need to emit the name path.
            }
             _ => return Err(Error::CompilationError(format!("Expression {:?} not supported yet", expr))),
        }

        Ok(())
    }

    // ★ 追加: パターン生成
    fn gen_pattern(&mut self, pattern: &Pattern) -> FlunoResult<()> {
        match pattern {
            Pattern::Identifier { name, .. } => self.push(&name.name),
            
            // ワイルドカード (_)
            Pattern::Wildcard { .. } => self.push("_"),
            
            // リテラル (1, "text", true)
            Pattern::Literal { value, .. } => self.gen_literal(value)?,

            // ★追加: Option::Some
            Pattern::Some { pattern, .. } => {
                self.push("Some(");
                self.gen_pattern(pattern)?;
                self.push(")");
            },

            // ★追加: Option::None
            Pattern::None { .. } => self.push("None"),

            // ★追加: Result::Ok
            Pattern::Ok { pattern, .. } => {
                self.push("Ok(");
                self.gen_pattern(pattern)?;
                self.push(")");
            },

            // ★追加: Result::Err
            Pattern::Err { pattern, .. } => {
                self.push("Err(");
                self.gen_pattern(pattern)?;
                self.push(")");
            },

            // ★追加: タプル (x, y)
            Pattern::Tuple { patterns, .. } => {
                self.push("(");
                for (i, p) in patterns.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.gen_pattern(p)?;
                }
                self.push(")");
            },

            Pattern::Enum { name, variant, args, named_fields, .. } => {
                self.push(&name.name);
                self.push("::");
                self.push(&variant.name);
                
                if let Some(fields) = named_fields {
                    self.push(" { ");
                    for (i, field) in fields.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        self.push(&field.name.name);
                        if let Some(pat) = &field.pattern {
                            self.push(": ");
                            self.gen_pattern(pat)?;
                        }
                    }
                    self.push(" }");
                } else if !args.is_empty() {
                    self.push("(");
                    for (i, arg) in args.iter().enumerate() {
                        if i > 0 { self.push(", "); }
                        self.gen_pattern(arg)?;
                    }
                    self.push(")");
                }
            },

            Pattern::Struct { name, fields, .. } => {
                self.push(&name.name);
                self.push(" { ");
                for (i, field) in fields.iter().enumerate() {
                    if i > 0 { self.push(", "); }
                    self.push(&field.name.name);
                    if let Some(pat) = &field.pattern {
                        self.push(": ");
                        self.gen_pattern(pat)?;
                    }
                }
                self.push(" }");
            },

            _ => return Err(Error::CompilationError(format!("Pattern {:?} not supported yet", pattern))),
        }
        Ok(())
    }

    fn gen_literal(&mut self, lit: &Literal) -> FlunoResult<()> {
        match lit {
            Literal::Int(i) => self.push(&i.to_string()),
            Literal::Float(f) => {
                let mut s = f.to_string();
                if !s.contains('.') { s.push_str(".0"); }
                self.push(&format!("ADFloat::from({})", s));
            }
            Literal::Bool(b) => self.push(&b.to_string()),
            Literal::String(s) => self.push(&format!("\"{}\".to_string()", s)),
            Literal::Unit => self.push("()"),
        }
        Ok(())
    }

    // --- Helper methods ---

    fn push(&mut self, s: &str) {
        self.code.push_str(s);
    }

    fn push_line(&mut self, s: &str) {
        self.indent();
        self.code.push_str(s);
        self.code.push('\n');
    }

    fn indent(&mut self) {
        self.code.push_str(&"    ".repeat(self.indent_level));
    }
}
